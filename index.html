// ObjetivosTree.tsx - componente de visualização de metas e resultados interativos com filtros

import React, { useEffect, useRef, useState } from "react";
import * as d3 from "d3";
import html2canvas from "html2canvas";
import jsPDF from "jspdf";
import {
  Card,
  CardContent,
} from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { saveAs } from "file-saver";

interface Indicador {
  nome: string;
  resultado: number;
  meta: number;
  time: string;
  mes: string;
  cor: string;
}

interface Objetivo {
  nome: string;
  indicadores: Indicador[];
  time: string;
  mes: string;
}

interface Empresa {
  nome: string;
  objetivos: Objetivo[];
}

interface Props {
  dados: Empresa[];
}

export default function ObjetivosTree({ dados }: Props) {
  const svgRef = useRef<SVGSVGElement | null>(null);
  const wrapperRef = useRef<HTMLDivElement | null>(null);
  const [mesSelecionado, setMesSelecionado] = useState<string>("");
  const [timeSelecionado, setTimeSelecionado] = useState<string>("");
  const [mostrarApenasNaoAtingidos, setMostrarApenasNaoAtingidos] = useState(false);

  const mesesDisponiveis = Array.from(
    new Set(dados.flatMap(emp => emp.objetivos.map(obj => obj.mes)))
  );

  const timesDisponiveis = Array.from(
    new Set(dados.flatMap(emp => emp.objetivos.map(obj => obj.time)))
  );

  const filtrarDados = () => {
    return dados.map(empresa => ({
      ...empresa,
      objetivos: empresa.objetivos.filter(obj => {
        const condMes = mesSelecionado ? obj.mes === mesSelecionado : true;
        const condTime = timeSelecionado ? obj.time === timeSelecionado : true;
        return condMes && condTime;
      }).map(obj => ({
        ...obj,
        indicadores: obj.indicadores.filter(ind => {
          if (!mostrarApenasNaoAtingidos) return true;
          return ind.resultado < ind.meta;
        })
      })).filter(obj => obj.indicadores.length > 0)
    })).filter(emp => emp.objetivos.length > 0);
  };

  useEffect(() => {
    const dadosFiltrados = filtrarDados();
    const root = d3.hierarchy({ nome: "Empresa", children: dadosFiltrados }, d => d.objetivos || d.children);

    root.sum(() => 1);

    const treeLayout = d3.tree<any>().nodeSize([100, 300]);
    treeLayout(root);

    const svg = d3.select(svgRef.current);
    svg.selectAll("*").remove();

    const g = svg
      .append("g")
      .attr("transform", "translate(200, 50)");

    const link = g
      .selectAll(".link")
      .data(root.links())
      .enter()
      .append("line")
      .attr("class", "link")
      .attr("x1", d => d.source.y)
      .attr("y1", d => d.source.x)
      .attr("x2", d => d.target.y)
      .attr("y2", d => d.target.x)
      .attr("stroke", "#ccc");

    const node = g
      .selectAll(".node")
      .data(root.descendants())
      .enter()
      .append("g")
      .attr("class", "node")
      .attr("transform", d => `translate(${d.y},${d.x})`);

    node
      .append("circle")
      .attr("r", 25)
      .attr("fill", d => {
        if (!d.data.indicadores) return "#e0e0e0";
        const allOK = d.data.indicadores.every((i: Indicador) => i.resultado >= i.meta);
        return allOK ? "#a7f3d0" : "#fecaca";
      })
      .attr("stroke", "#333")
      .on("mouseover", function (event, d) {
        const tooltip = d3.select("#tooltip");
        if (d.data.indicadores) {
          const html = d.data.indicadores
            .map((i: Indicador) => `
              <strong>${i.nome}</strong><br/>
              Time: ${i.time}<br/>
              Resultado: ${i.resultado}<br/>
              Meta: ${i.meta}<br/><br/>
            `)
            .join("");
          tooltip.html(html)
            .style("left", event.pageX + 10 + "px")
            .style("top", event.pageY + "px")
            .style("opacity", 1);
        }
      })
      .on("mouseout", () => {
        d3.select("#tooltip").style("opacity", 0);
      });

    node
      .append("text")
      .attr("dy", 4)
      .attr("x", d => (d.children ? -30 : 30))
      .style("text-anchor", d => (d.children ? "end" : "start"))
      .text(d => d.data.nome);
  }, [mesSelecionado, timeSelecionado, mostrarApenasNaoAtingidos]);

  const exportarImagem = async () => {
    if (!wrapperRef.current) return;
    const canvas = await html2canvas(wrapperRef.current);
    canvas.toBlob(blob => {
      if (blob) saveAs(blob, "objetivos.png");
    });
  };

  const exportarPDF = async () => {
    if (!wrapperRef.current) return;
    const canvas = await html2canvas(wrapperRef.current);
    const imgData = canvas.toDataURL("image/png");
    const pdf = new jsPDF();
    pdf.addImage(imgData, "PNG", 10, 10, 180, 0);
    pdf.save("objetivos.pdf");
  };

  return (
    <div className="space-y-4">
      <div className="flex flex-wrap gap-4">
        <Select onValueChange={setMesSelecionado}>
          <SelectTrigger className="w-[200px]">
            <SelectValue placeholder="Selecione o mês" />
          </SelectTrigger>
          <SelectContent>
            {mesesDisponiveis.map(m => (
              <SelectItem key={m} value={m}>{m}</SelectItem>
            ))}
          </SelectContent>
        </Select>

        <Select onValueChange={setTimeSelecionado}>
          <SelectTrigger className="w-[200px]">
            <SelectValue placeholder="Selecione o time" />
          </SelectTrigger>
          <SelectContent>
            {timesDisponiveis.map(t => (
              <SelectItem key={t} value={t}>{t}</SelectItem>
            ))}
          </SelectContent>
        </Select>

        <label className="flex items-center gap-2">
          <input
            type="checkbox"
            checked={mostrarApenasNaoAtingidos}
            onChange={e => setMostrarApenasNaoAtingidos(e.target.checked)}
          />
          Mostrar apenas não atingidos
        </label>

        <Button onClick={exportarImagem}>Exportar PNG</Button>
        <Button onClick={exportarPDF}>Exportar PDF</Button>
      </div>

      <div ref={wrapperRef} className="relative overflow-auto rounded-xl border p-4 shadow-md">
        <svg ref={svgRef} width={1200} height={800} />
        <div
          id="tooltip"
          className="absolute z-10 max-w-xs rounded bg-white p-2 text-sm shadow-md"
          style={{ opacity: 0, pointerEvents: "none", position: "absolute" }}
        ></div>
      </div>
    </div>
  );
}
